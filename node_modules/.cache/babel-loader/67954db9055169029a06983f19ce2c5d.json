{"ast":null,"code":"let Browsers = require('./browsers');\n\nlet vendor = require('./vendor');\n\nlet utils = require('./utils');\n/**\n * Recursively clone objects\n */\n\n\nfunction clone(obj, parent) {\n  let cloned = new obj.constructor();\n\n  for (let i of Object.keys(obj || {})) {\n    let value = obj[i];\n\n    if (i === 'parent' && typeof value === 'object') {\n      if (parent) {\n        cloned[i] = parent;\n      }\n    } else if (i === 'source' || i === null) {\n      cloned[i] = value;\n    } else if (Array.isArray(value)) {\n      cloned[i] = value.map(x => clone(x, cloned));\n    } else if (i !== '_autoprefixerPrefix' && i !== '_autoprefixerValues') {\n      if (typeof value === 'object' && value !== null) {\n        value = clone(value, cloned);\n      }\n\n      cloned[i] = value;\n    }\n  }\n\n  return cloned;\n}\n\nclass Prefixer {\n  /**\n   * Add hack to selected names\n   */\n  static hack(klass) {\n    if (!this.hacks) {\n      this.hacks = {};\n    }\n\n    return klass.names.map(name => {\n      this.hacks[name] = klass;\n      return this.hacks[name];\n    });\n  }\n  /**\n   * Load hacks for some names\n   */\n\n\n  static load(name, prefixes, all) {\n    let Klass = this.hacks && this.hacks[name];\n\n    if (Klass) {\n      return new Klass(name, prefixes, all);\n    } else {\n      return new this(name, prefixes, all);\n    }\n  }\n  /**\n   * Clone node and clean autprefixer custom caches\n   */\n\n\n  static clone(node, overrides) {\n    let cloned = clone(node);\n\n    for (let name in overrides) {\n      cloned[name] = overrides[name];\n    }\n\n    return cloned;\n  }\n\n  constructor(name, prefixes, all) {\n    this.prefixes = prefixes;\n    this.name = name;\n    this.all = all;\n  }\n  /**\n   * Find prefix in node parents\n   */\n\n\n  parentPrefix(node) {\n    let prefix;\n\n    if (typeof node._autoprefixerPrefix !== 'undefined') {\n      prefix = node._autoprefixerPrefix;\n    } else if (node.type === 'decl' && node.prop[0] === '-') {\n      prefix = vendor.prefix(node.prop);\n    } else if (node.type === 'root') {\n      prefix = false;\n    } else if (node.type === 'rule' && node.selector.includes(':-') && /:(-\\w+-)/.test(node.selector)) {\n      prefix = node.selector.match(/:(-\\w+-)/)[1];\n    } else if (node.type === 'atrule' && node.name[0] === '-') {\n      prefix = vendor.prefix(node.name);\n    } else {\n      prefix = this.parentPrefix(node.parent);\n    }\n\n    if (!Browsers.prefixes().includes(prefix)) {\n      prefix = false;\n    }\n\n    node._autoprefixerPrefix = prefix;\n    return node._autoprefixerPrefix;\n  }\n  /**\n   * Clone node with prefixes\n   */\n\n\n  process(node, result) {\n    if (!this.check(node)) {\n      return undefined;\n    }\n\n    let parent = this.parentPrefix(node);\n    let prefixes = this.prefixes.filter(prefix => !parent || parent === utils.removeNote(prefix));\n    let added = [];\n\n    for (let prefix of prefixes) {\n      if (this.add(node, prefix, added.concat([prefix]), result)) {\n        added.push(prefix);\n      }\n    }\n\n    return added;\n  }\n  /**\n   * Shortcut for Prefixer.clone\n   */\n\n\n  clone(node, overrides) {\n    return Prefixer.clone(node, overrides);\n  }\n\n}\n\nmodule.exports = Prefixer;","map":{"version":3,"sources":["/home/silas/Desktop/Program/goldenOwl/TrainingGit/node_modules/autoprefixer/lib/prefixer.js"],"names":["Browsers","require","vendor","utils","clone","obj","parent","cloned","constructor","i","Object","keys","value","Array","isArray","map","x","Prefixer","hack","klass","hacks","names","name","load","prefixes","all","Klass","node","overrides","parentPrefix","prefix","_autoprefixerPrefix","type","prop","selector","includes","test","match","process","result","check","undefined","filter","removeNote","added","add","concat","push","module","exports"],"mappings":"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","sourcesContent":["let Browsers = require('./browsers')\nlet vendor = require('./vendor')\nlet utils = require('./utils')\n\n/**\n * Recursively clone objects\n */\nfunction clone (obj, parent) {\n  let cloned = new obj.constructor()\n\n  for (let i of Object.keys(obj || {})) {\n    let value = obj[i]\n    if (i === 'parent' && typeof value === 'object') {\n      if (parent) {\n        cloned[i] = parent\n      }\n    } else if (i === 'source' || i === null) {\n      cloned[i] = value\n    } else if (Array.isArray(value)) {\n      cloned[i] = value.map(x => clone(x, cloned))\n    } else if (i !== '_autoprefixerPrefix' && i !== '_autoprefixerValues') {\n      if (typeof value === 'object' && value !== null) {\n        value = clone(value, cloned)\n      }\n      cloned[i] = value\n    }\n  }\n\n  return cloned\n}\n\nclass Prefixer {\n  /**\n   * Add hack to selected names\n   */\n  static hack (klass) {\n    if (!this.hacks) {\n      this.hacks = {}\n    }\n    return klass.names.map(name => {\n      this.hacks[name] = klass\n      return this.hacks[name]\n    })\n  }\n\n  /**\n   * Load hacks for some names\n   */\n  static load (name, prefixes, all) {\n    let Klass = this.hacks && this.hacks[name]\n    if (Klass) {\n      return new Klass(name, prefixes, all)\n    } else {\n      return new this(name, prefixes, all)\n    }\n  }\n\n  /**\n   * Clone node and clean autprefixer custom caches\n   */\n  static clone (node, overrides) {\n    let cloned = clone(node)\n    for (let name in overrides) {\n      cloned[name] = overrides[name]\n    }\n    return cloned\n  }\n\n  constructor (name, prefixes, all) {\n    this.prefixes = prefixes\n    this.name = name\n    this.all = all\n  }\n\n  /**\n   * Find prefix in node parents\n   */\n  parentPrefix (node) {\n    let prefix\n\n    if (typeof node._autoprefixerPrefix !== 'undefined') {\n      prefix = node._autoprefixerPrefix\n    } else if (node.type === 'decl' && node.prop[0] === '-') {\n      prefix = vendor.prefix(node.prop)\n    } else if (node.type === 'root') {\n      prefix = false\n    } else if (\n      node.type === 'rule' &&\n      node.selector.includes(':-') &&\n      /:(-\\w+-)/.test(node.selector)\n    ) {\n      prefix = node.selector.match(/:(-\\w+-)/)[1]\n    } else if (node.type === 'atrule' && node.name[0] === '-') {\n      prefix = vendor.prefix(node.name)\n    } else {\n      prefix = this.parentPrefix(node.parent)\n    }\n\n    if (!Browsers.prefixes().includes(prefix)) {\n      prefix = false\n    }\n\n    node._autoprefixerPrefix = prefix\n\n    return node._autoprefixerPrefix\n  }\n\n  /**\n   * Clone node with prefixes\n   */\n  process (node, result) {\n    if (!this.check(node)) {\n      return undefined\n    }\n\n    let parent = this.parentPrefix(node)\n\n    let prefixes = this.prefixes.filter(\n      prefix => !parent || parent === utils.removeNote(prefix)\n    )\n\n    let added = []\n    for (let prefix of prefixes) {\n      if (this.add(node, prefix, added.concat([prefix]), result)) {\n        added.push(prefix)\n      }\n    }\n\n    return added\n  }\n\n  /**\n   * Shortcut for Prefixer.clone\n   */\n  clone (node, overrides) {\n    return Prefixer.clone(node, overrides)\n  }\n}\n\nmodule.exports = Prefixer\n"]},"metadata":{},"sourceType":"script"}