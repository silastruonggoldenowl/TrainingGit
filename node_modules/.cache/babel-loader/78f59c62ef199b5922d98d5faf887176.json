{"ast":null,"code":"'use strict';\n\nlet Declaration = require('./declaration');\n\nlet PreviousMap = require('./previous-map');\n\nlet Comment = require('./comment');\n\nlet AtRule = require('./at-rule');\n\nlet Input = require('./input');\n\nlet Root = require('./root');\n\nlet Rule = require('./rule');\n\nfunction fromJSON(json, inputs) {\n  let {\n    inputs: ownInputs,\n    ...defaults\n  } = json;\n\n  if (ownInputs) {\n    inputs = [];\n\n    for (let input of ownInputs) {\n      let inputHydrated = { ...input,\n        __proto__: Input.prototype\n      };\n\n      if (inputHydrated.map) {\n        inputHydrated.map = { ...inputHydrated.map,\n          __proto__: PreviousMap.prototype\n        };\n      }\n\n      inputs.push(inputHydrated);\n    }\n  }\n\n  if (defaults.nodes) {\n    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs));\n  }\n\n  if (defaults.source) {\n    let {\n      inputId,\n      ...source\n    } = defaults.source;\n    defaults.source = source;\n\n    if (inputId != null) {\n      defaults.source.input = inputs[inputId];\n    }\n  }\n\n  if (defaults.type === 'root') {\n    return new Root(defaults);\n  } else if (defaults.type === 'decl') {\n    return new Declaration(defaults);\n  } else if (defaults.type === 'rule') {\n    return new Rule(defaults);\n  } else if (defaults.type === 'comment') {\n    return new Comment(defaults);\n  } else if (defaults.type === 'atrule') {\n    return new AtRule(defaults);\n  } else {\n    throw new Error('Unknown node type: ' + json.type);\n  }\n}\n\nmodule.exports = fromJSON;\nfromJSON.default = fromJSON;","map":{"version":3,"sources":["/home/silas/Desktop/Program/goldenOwl/TrainingGit/node_modules/postcss/lib/fromJSON.js"],"names":["Declaration","require","PreviousMap","Comment","AtRule","Input","Root","Rule","fromJSON","json","inputs","ownInputs","defaults","input","inputHydrated","__proto__","prototype","map","push","nodes","n","source","inputId","type","Error","module","exports","default"],"mappings":"AAAA;;AAEA,IAAIA,WAAW,GAAGC,OAAO,CAAC,eAAD,CAAzB;;AACA,IAAIC,WAAW,GAAGD,OAAO,CAAC,gBAAD,CAAzB;;AACA,IAAIE,OAAO,GAAGF,OAAO,CAAC,WAAD,CAArB;;AACA,IAAIG,MAAM,GAAGH,OAAO,CAAC,WAAD,CAApB;;AACA,IAAII,KAAK,GAAGJ,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIK,IAAI,GAAGL,OAAO,CAAC,QAAD,CAAlB;;AACA,IAAIM,IAAI,GAAGN,OAAO,CAAC,QAAD,CAAlB;;AAEA,SAASO,QAAT,CAAmBC,IAAnB,EAAyBC,MAAzB,EAAiC;AAC/B,MAAI;AAAEA,IAAAA,MAAM,EAAEC,SAAV;AAAqB,OAAGC;AAAxB,MAAqCH,IAAzC;;AACA,MAAIE,SAAJ,EAAe;AACbD,IAAAA,MAAM,GAAG,EAAT;;AACA,SAAK,IAAIG,KAAT,IAAkBF,SAAlB,EAA6B;AAC3B,UAAIG,aAAa,GAAG,EAAE,GAAGD,KAAL;AAAYE,QAAAA,SAAS,EAAEV,KAAK,CAACW;AAA7B,OAApB;;AACA,UAAIF,aAAa,CAACG,GAAlB,EAAuB;AACrBH,QAAAA,aAAa,CAACG,GAAd,GAAoB,EAClB,GAAGH,aAAa,CAACG,GADC;AAElBF,UAAAA,SAAS,EAAEb,WAAW,CAACc;AAFL,SAApB;AAID;;AACDN,MAAAA,MAAM,CAACQ,IAAP,CAAYJ,aAAZ;AACD;AACF;;AACD,MAAIF,QAAQ,CAACO,KAAb,EAAoB;AAClBP,IAAAA,QAAQ,CAACO,KAAT,GAAiBV,IAAI,CAACU,KAAL,CAAWF,GAAX,CAAeG,CAAC,IAAIZ,QAAQ,CAACY,CAAD,EAAIV,MAAJ,CAA5B,CAAjB;AACD;;AACD,MAAIE,QAAQ,CAACS,MAAb,EAAqB;AACnB,QAAI;AAAEC,MAAAA,OAAF;AAAW,SAAGD;AAAd,QAAyBT,QAAQ,CAACS,MAAtC;AACAT,IAAAA,QAAQ,CAACS,MAAT,GAAkBA,MAAlB;;AACA,QAAIC,OAAO,IAAI,IAAf,EAAqB;AACnBV,MAAAA,QAAQ,CAACS,MAAT,CAAgBR,KAAhB,GAAwBH,MAAM,CAACY,OAAD,CAA9B;AACD;AACF;;AACD,MAAIV,QAAQ,CAACW,IAAT,KAAkB,MAAtB,EAA8B;AAC5B,WAAO,IAAIjB,IAAJ,CAASM,QAAT,CAAP;AACD,GAFD,MAEO,IAAIA,QAAQ,CAACW,IAAT,KAAkB,MAAtB,EAA8B;AACnC,WAAO,IAAIvB,WAAJ,CAAgBY,QAAhB,CAAP;AACD,GAFM,MAEA,IAAIA,QAAQ,CAACW,IAAT,KAAkB,MAAtB,EAA8B;AACnC,WAAO,IAAIhB,IAAJ,CAASK,QAAT,CAAP;AACD,GAFM,MAEA,IAAIA,QAAQ,CAACW,IAAT,KAAkB,SAAtB,EAAiC;AACtC,WAAO,IAAIpB,OAAJ,CAAYS,QAAZ,CAAP;AACD,GAFM,MAEA,IAAIA,QAAQ,CAACW,IAAT,KAAkB,QAAtB,EAAgC;AACrC,WAAO,IAAInB,MAAJ,CAAWQ,QAAX,CAAP;AACD,GAFM,MAEA;AACL,UAAM,IAAIY,KAAJ,CAAU,wBAAwBf,IAAI,CAACc,IAAvC,CAAN;AACD;AACF;;AAEDE,MAAM,CAACC,OAAP,GAAiBlB,QAAjB;AACAA,QAAQ,CAACmB,OAAT,GAAmBnB,QAAnB","sourcesContent":["'use strict'\n\nlet Declaration = require('./declaration')\nlet PreviousMap = require('./previous-map')\nlet Comment = require('./comment')\nlet AtRule = require('./at-rule')\nlet Input = require('./input')\nlet Root = require('./root')\nlet Rule = require('./rule')\n\nfunction fromJSON (json, inputs) {\n  let { inputs: ownInputs, ...defaults } = json\n  if (ownInputs) {\n    inputs = []\n    for (let input of ownInputs) {\n      let inputHydrated = { ...input, __proto__: Input.prototype }\n      if (inputHydrated.map) {\n        inputHydrated.map = {\n          ...inputHydrated.map,\n          __proto__: PreviousMap.prototype\n        }\n      }\n      inputs.push(inputHydrated)\n    }\n  }\n  if (defaults.nodes) {\n    defaults.nodes = json.nodes.map(n => fromJSON(n, inputs))\n  }\n  if (defaults.source) {\n    let { inputId, ...source } = defaults.source\n    defaults.source = source\n    if (inputId != null) {\n      defaults.source.input = inputs[inputId]\n    }\n  }\n  if (defaults.type === 'root') {\n    return new Root(defaults)\n  } else if (defaults.type === 'decl') {\n    return new Declaration(defaults)\n  } else if (defaults.type === 'rule') {\n    return new Rule(defaults)\n  } else if (defaults.type === 'comment') {\n    return new Comment(defaults)\n  } else if (defaults.type === 'atrule') {\n    return new AtRule(defaults)\n  } else {\n    throw new Error('Unknown node type: ' + json.type)\n  }\n}\n\nmodule.exports = fromJSON\nfromJSON.default = fromJSON\n"]},"metadata":{},"sourceType":"script"}