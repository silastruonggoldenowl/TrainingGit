{"ast":null,"code":"'use strict';\n\nlet {\n  dirname,\n  resolve,\n  relative,\n  sep\n} = require('path');\n\nlet {\n  pathToFileURL\n} = require('url');\n\nlet mozilla = require('source-map');\n\nclass MapGenerator {\n  constructor(stringify, root, opts) {\n    this.stringify = stringify;\n    this.mapOpts = opts.map || {};\n    this.root = root;\n    this.opts = opts;\n  }\n\n  isMap() {\n    if (typeof this.opts.map !== 'undefined') {\n      return !!this.opts.map;\n    }\n\n    return this.previous().length > 0;\n  }\n\n  previous() {\n    if (!this.previousMaps) {\n      this.previousMaps = [];\n      this.root.walk(node => {\n        if (node.source && node.source.input.map) {\n          let map = node.source.input.map;\n\n          if (!this.previousMaps.includes(map)) {\n            this.previousMaps.push(map);\n          }\n        }\n      });\n    }\n\n    return this.previousMaps;\n  }\n\n  isInline() {\n    if (typeof this.mapOpts.inline !== 'undefined') {\n      return this.mapOpts.inline;\n    }\n\n    let annotation = this.mapOpts.annotation;\n\n    if (typeof annotation !== 'undefined' && annotation !== true) {\n      return false;\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(i => i.inline);\n    }\n\n    return true;\n  }\n\n  isSourcesContent() {\n    if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n      return this.mapOpts.sourcesContent;\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(i => i.withContent());\n    }\n\n    return true;\n  }\n\n  clearAnnotation() {\n    if (this.mapOpts.annotation === false) return;\n    let node;\n\n    for (let i = this.root.nodes.length - 1; i >= 0; i--) {\n      node = this.root.nodes[i];\n      if (node.type !== 'comment') continue;\n\n      if (node.text.indexOf('# sourceMappingURL=') === 0) {\n        this.root.removeChild(i);\n      }\n    }\n  }\n\n  setSourcesContent() {\n    let already = {};\n    this.root.walk(node => {\n      if (node.source) {\n        let from = node.source.input.from;\n\n        if (from && !already[from]) {\n          already[from] = true;\n          this.map.setSourceContent(this.toUrl(this.path(from)), node.source.input.css);\n        }\n      }\n    });\n  }\n\n  applyPrevMaps() {\n    for (let prev of this.previous()) {\n      let from = this.toUrl(this.path(prev.file));\n      let root = prev.root || dirname(prev.file);\n      let map;\n\n      if (this.mapOpts.sourcesContent === false) {\n        map = new mozilla.SourceMapConsumer(prev.text);\n\n        if (map.sourcesContent) {\n          map.sourcesContent = map.sourcesContent.map(() => null);\n        }\n      } else {\n        map = prev.consumer();\n      }\n\n      this.map.applySourceMap(map, from, this.toUrl(this.path(root)));\n    }\n  }\n\n  isAnnotation() {\n    if (this.isInline()) {\n      return true;\n    }\n\n    if (typeof this.mapOpts.annotation !== 'undefined') {\n      return this.mapOpts.annotation;\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(i => i.annotation);\n    }\n\n    return true;\n  }\n\n  toBase64(str) {\n    if (Buffer) {\n      return Buffer.from(str).toString('base64');\n    } else {\n      // istanbul ignore next\n      return window.btoa(unescape(encodeURIComponent(str)));\n    }\n  }\n\n  addAnnotation() {\n    let content;\n\n    if (this.isInline()) {\n      content = 'data:application/json;base64,' + this.toBase64(this.map.toString());\n    } else if (typeof this.mapOpts.annotation === 'string') {\n      content = this.mapOpts.annotation;\n    } else if (typeof this.mapOpts.annotation === 'function') {\n      content = this.mapOpts.annotation(this.opts.to, this.root);\n    } else {\n      content = this.outputFile() + '.map';\n    }\n\n    let eol = '\\n';\n    if (this.css.includes('\\r\\n')) eol = '\\r\\n';\n    this.css += eol + '/*# sourceMappingURL=' + content + ' */';\n  }\n\n  outputFile() {\n    if (this.opts.to) {\n      return this.path(this.opts.to);\n    }\n\n    if (this.opts.from) {\n      return this.path(this.opts.from);\n    }\n\n    return 'to.css';\n  }\n\n  generateMap() {\n    this.generateString();\n    if (this.isSourcesContent()) this.setSourcesContent();\n    if (this.previous().length > 0) this.applyPrevMaps();\n    if (this.isAnnotation()) this.addAnnotation();\n\n    if (this.isInline()) {\n      return [this.css];\n    }\n\n    return [this.css, this.map];\n  }\n\n  path(file) {\n    if (file.indexOf('<') === 0) return file;\n    if (/^\\w+:\\/\\//.test(file)) return file;\n    if (this.mapOpts.absolute) return file;\n    let from = this.opts.to ? dirname(this.opts.to) : '.';\n\n    if (typeof this.mapOpts.annotation === 'string') {\n      from = dirname(resolve(from, this.mapOpts.annotation));\n    }\n\n    file = relative(from, file);\n    return file;\n  }\n\n  toUrl(path) {\n    if (sep === '\\\\') {\n      // istanbul ignore next\n      path = path.replace(/\\\\/g, '/');\n    }\n\n    return encodeURI(path).replace(/[#?]/g, encodeURIComponent);\n  }\n\n  sourcePath(node) {\n    if (this.mapOpts.from) {\n      return this.toUrl(this.mapOpts.from);\n    } else if (this.mapOpts.absolute) {\n      return pathToFileURL(node.source.input.from).toString();\n    } else {\n      return this.toUrl(this.path(node.source.input.from));\n    }\n  }\n\n  generateString() {\n    this.css = '';\n    this.map = new mozilla.SourceMapGenerator({\n      file: this.outputFile()\n    });\n    let line = 1;\n    let column = 1;\n    let lines, last;\n    this.stringify(this.root, (str, node, type) => {\n      this.css += str;\n\n      if (node && type !== 'end') {\n        if (node.source && node.source.start) {\n          this.map.addMapping({\n            source: this.sourcePath(node),\n            generated: {\n              line,\n              column: column - 1\n            },\n            original: {\n              line: node.source.start.line,\n              column: node.source.start.column - 1\n            }\n          });\n        } else {\n          this.map.addMapping({\n            source: '<no source>',\n            original: {\n              line: 1,\n              column: 0\n            },\n            generated: {\n              line,\n              column: column - 1\n            }\n          });\n        }\n      }\n\n      lines = str.match(/\\n/g);\n\n      if (lines) {\n        line += lines.length;\n        last = str.lastIndexOf('\\n');\n        column = str.length - last;\n      } else {\n        column += str.length;\n      }\n\n      if (node && type !== 'start') {\n        let p = node.parent || {\n          raws: {}\n        };\n\n        if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {\n          if (node.source && node.source.end) {\n            this.map.addMapping({\n              source: this.sourcePath(node),\n              generated: {\n                line,\n                column: column - 2\n              },\n              original: {\n                line: node.source.end.line,\n                column: node.source.end.column - 1\n              }\n            });\n          } else {\n            this.map.addMapping({\n              source: '<no source>',\n              original: {\n                line: 1,\n                column: 0\n              },\n              generated: {\n                line,\n                column: column - 1\n              }\n            });\n          }\n        }\n      }\n    });\n  }\n\n  generate() {\n    this.clearAnnotation();\n\n    if (this.isMap()) {\n      return this.generateMap();\n    }\n\n    let result = '';\n    this.stringify(this.root, i => {\n      result += i;\n    });\n    return [result];\n  }\n\n}\n\nmodule.exports = MapGenerator;","map":{"version":3,"sources":["/home/silas/Desktop/Program/goldenOwl/TrainingGit/node_modules/postcss/lib/map-generator.js"],"names":["dirname","resolve","relative","sep","require","pathToFileURL","mozilla","MapGenerator","constructor","stringify","root","opts","mapOpts","map","isMap","previous","length","previousMaps","walk","node","source","input","includes","push","isInline","inline","annotation","some","i","isSourcesContent","sourcesContent","withContent","clearAnnotation","nodes","type","text","indexOf","removeChild","setSourcesContent","already","from","setSourceContent","toUrl","path","css","applyPrevMaps","prev","file","SourceMapConsumer","consumer","applySourceMap","isAnnotation","toBase64","str","Buffer","toString","window","btoa","unescape","encodeURIComponent","addAnnotation","content","to","outputFile","eol","generateMap","generateString","test","absolute","replace","encodeURI","sourcePath","SourceMapGenerator","line","column","lines","last","start","addMapping","generated","original","match","lastIndexOf","p","parent","raws","semicolon","end","generate","result","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nlet { dirname, resolve, relative, sep } = require('path')\nlet { pathToFileURL } = require('url')\nlet mozilla = require('source-map')\n\nclass MapGenerator {\n  constructor (stringify, root, opts) {\n    this.stringify = stringify\n    this.mapOpts = opts.map || {}\n    this.root = root\n    this.opts = opts\n  }\n\n  isMap () {\n    if (typeof this.opts.map !== 'undefined') {\n      return !!this.opts.map\n    }\n    return this.previous().length > 0\n  }\n\n  previous () {\n    if (!this.previousMaps) {\n      this.previousMaps = []\n      this.root.walk(node => {\n        if (node.source && node.source.input.map) {\n          let map = node.source.input.map\n          if (!this.previousMaps.includes(map)) {\n            this.previousMaps.push(map)\n          }\n        }\n      })\n    }\n\n    return this.previousMaps\n  }\n\n  isInline () {\n    if (typeof this.mapOpts.inline !== 'undefined') {\n      return this.mapOpts.inline\n    }\n\n    let annotation = this.mapOpts.annotation\n    if (typeof annotation !== 'undefined' && annotation !== true) {\n      return false\n    }\n\n    if (this.previous().length) {\n      return this.previous().some(i => i.inline)\n    }\n    return true\n  }\n\n  isSourcesContent () {\n    if (typeof this.mapOpts.sourcesContent !== 'undefined') {\n      return this.mapOpts.sourcesContent\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.withContent())\n    }\n    return true\n  }\n\n  clearAnnotation () {\n    if (this.mapOpts.annotation === false) return\n\n    let node\n    for (let i = this.root.nodes.length - 1; i >= 0; i--) {\n      node = this.root.nodes[i]\n      if (node.type !== 'comment') continue\n      if (node.text.indexOf('# sourceMappingURL=') === 0) {\n        this.root.removeChild(i)\n      }\n    }\n  }\n\n  setSourcesContent () {\n    let already = {}\n    this.root.walk(node => {\n      if (node.source) {\n        let from = node.source.input.from\n        if (from && !already[from]) {\n          already[from] = true\n          this.map.setSourceContent(\n            this.toUrl(this.path(from)),\n            node.source.input.css\n          )\n        }\n      }\n    })\n  }\n\n  applyPrevMaps () {\n    for (let prev of this.previous()) {\n      let from = this.toUrl(this.path(prev.file))\n      let root = prev.root || dirname(prev.file)\n      let map\n\n      if (this.mapOpts.sourcesContent === false) {\n        map = new mozilla.SourceMapConsumer(prev.text)\n        if (map.sourcesContent) {\n          map.sourcesContent = map.sourcesContent.map(() => null)\n        }\n      } else {\n        map = prev.consumer()\n      }\n\n      this.map.applySourceMap(map, from, this.toUrl(this.path(root)))\n    }\n  }\n\n  isAnnotation () {\n    if (this.isInline()) {\n      return true\n    }\n    if (typeof this.mapOpts.annotation !== 'undefined') {\n      return this.mapOpts.annotation\n    }\n    if (this.previous().length) {\n      return this.previous().some(i => i.annotation)\n    }\n    return true\n  }\n\n  toBase64 (str) {\n    if (Buffer) {\n      return Buffer.from(str).toString('base64')\n    } else {\n      // istanbul ignore next\n      return window.btoa(unescape(encodeURIComponent(str)))\n    }\n  }\n\n  addAnnotation () {\n    let content\n\n    if (this.isInline()) {\n      content =\n        'data:application/json;base64,' + this.toBase64(this.map.toString())\n    } else if (typeof this.mapOpts.annotation === 'string') {\n      content = this.mapOpts.annotation\n    } else if (typeof this.mapOpts.annotation === 'function') {\n      content = this.mapOpts.annotation(this.opts.to, this.root)\n    } else {\n      content = this.outputFile() + '.map'\n    }\n\n    let eol = '\\n'\n    if (this.css.includes('\\r\\n')) eol = '\\r\\n'\n\n    this.css += eol + '/*# sourceMappingURL=' + content + ' */'\n  }\n\n  outputFile () {\n    if (this.opts.to) {\n      return this.path(this.opts.to)\n    }\n    if (this.opts.from) {\n      return this.path(this.opts.from)\n    }\n    return 'to.css'\n  }\n\n  generateMap () {\n    this.generateString()\n    if (this.isSourcesContent()) this.setSourcesContent()\n    if (this.previous().length > 0) this.applyPrevMaps()\n    if (this.isAnnotation()) this.addAnnotation()\n\n    if (this.isInline()) {\n      return [this.css]\n    }\n    return [this.css, this.map]\n  }\n\n  path (file) {\n    if (file.indexOf('<') === 0) return file\n    if (/^\\w+:\\/\\//.test(file)) return file\n    if (this.mapOpts.absolute) return file\n\n    let from = this.opts.to ? dirname(this.opts.to) : '.'\n\n    if (typeof this.mapOpts.annotation === 'string') {\n      from = dirname(resolve(from, this.mapOpts.annotation))\n    }\n\n    file = relative(from, file)\n    return file\n  }\n\n  toUrl (path) {\n    if (sep === '\\\\') {\n      // istanbul ignore next\n      path = path.replace(/\\\\/g, '/')\n    }\n    return encodeURI(path).replace(/[#?]/g, encodeURIComponent)\n  }\n\n  sourcePath (node) {\n    if (this.mapOpts.from) {\n      return this.toUrl(this.mapOpts.from)\n    } else if (this.mapOpts.absolute) {\n      return pathToFileURL(node.source.input.from).toString()\n    } else {\n      return this.toUrl(this.path(node.source.input.from))\n    }\n  }\n\n  generateString () {\n    this.css = ''\n    this.map = new mozilla.SourceMapGenerator({ file: this.outputFile() })\n\n    let line = 1\n    let column = 1\n\n    let lines, last\n    this.stringify(this.root, (str, node, type) => {\n      this.css += str\n\n      if (node && type !== 'end') {\n        if (node.source && node.source.start) {\n          this.map.addMapping({\n            source: this.sourcePath(node),\n            generated: { line, column: column - 1 },\n            original: {\n              line: node.source.start.line,\n              column: node.source.start.column - 1\n            }\n          })\n        } else {\n          this.map.addMapping({\n            source: '<no source>',\n            original: { line: 1, column: 0 },\n            generated: { line, column: column - 1 }\n          })\n        }\n      }\n\n      lines = str.match(/\\n/g)\n      if (lines) {\n        line += lines.length\n        last = str.lastIndexOf('\\n')\n        column = str.length - last\n      } else {\n        column += str.length\n      }\n\n      if (node && type !== 'start') {\n        let p = node.parent || { raws: {} }\n        if (node.type !== 'decl' || node !== p.last || p.raws.semicolon) {\n          if (node.source && node.source.end) {\n            this.map.addMapping({\n              source: this.sourcePath(node),\n              generated: { line, column: column - 2 },\n              original: {\n                line: node.source.end.line,\n                column: node.source.end.column - 1\n              }\n            })\n          } else {\n            this.map.addMapping({\n              source: '<no source>',\n              original: { line: 1, column: 0 },\n              generated: { line, column: column - 1 }\n            })\n          }\n        }\n      }\n    })\n  }\n\n  generate () {\n    this.clearAnnotation()\n\n    if (this.isMap()) {\n      return this.generateMap()\n    }\n\n    let result = ''\n    this.stringify(this.root, i => {\n      result += i\n    })\n    return [result]\n  }\n}\n\nmodule.exports = MapGenerator\n"]},"metadata":{},"sourceType":"script"}