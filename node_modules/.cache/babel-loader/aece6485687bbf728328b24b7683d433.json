{"ast":null,"code":"let Prefixer = require('./prefixer');\n\nlet Browsers = require('./browsers');\n\nlet utils = require('./utils');\n\nclass Declaration extends Prefixer {\n  /**\n   * Always true, because we already get prefixer by property name\n   */\n  check()\n  /* decl */\n  {\n    return true;\n  }\n  /**\n   * Return prefixed version of property\n   */\n\n\n  prefixed(prop, prefix) {\n    return prefix + prop;\n  }\n  /**\n   * Return unprefixed version of property\n   */\n\n\n  normalize(prop) {\n    return prop;\n  }\n  /**\n   * Check `value`, that it contain other prefixes, rather than `prefix`\n   */\n\n\n  otherPrefixes(value, prefix) {\n    for (let other of Browsers.prefixes()) {\n      if (other === prefix) {\n        continue;\n      }\n\n      if (value.includes(other)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Set prefix to declaration\n   */\n\n\n  set(decl, prefix) {\n    decl.prop = this.prefixed(decl.prop, prefix);\n    return decl;\n  }\n  /**\n   * Should we use visual cascade for prefixes\n   */\n\n\n  needCascade(decl) {\n    if (!decl._autoprefixerCascade) {\n      decl._autoprefixerCascade = this.all.options.cascade !== false && decl.raw('before').includes('\\n');\n    }\n\n    return decl._autoprefixerCascade;\n  }\n  /**\n   * Return maximum length of possible prefixed property\n   */\n\n\n  maxPrefixed(prefixes, decl) {\n    if (decl._autoprefixerMax) {\n      return decl._autoprefixerMax;\n    }\n\n    let max = 0;\n\n    for (let prefix of prefixes) {\n      prefix = utils.removeNote(prefix);\n\n      if (prefix.length > max) {\n        max = prefix.length;\n      }\n    }\n\n    decl._autoprefixerMax = max;\n    return decl._autoprefixerMax;\n  }\n  /**\n   * Calculate indentation to create visual cascade\n   */\n\n\n  calcBefore(prefixes, decl, prefix = '') {\n    let max = this.maxPrefixed(prefixes, decl);\n    let diff = max - utils.removeNote(prefix).length;\n    let before = decl.raw('before');\n\n    if (diff > 0) {\n      before += Array(diff).fill(' ').join('');\n    }\n\n    return before;\n  }\n  /**\n   * Remove visual cascade\n   */\n\n\n  restoreBefore(decl) {\n    let lines = decl.raw('before').split('\\n');\n    let min = lines[lines.length - 1];\n    this.all.group(decl).up(prefixed => {\n      let array = prefixed.raw('before').split('\\n');\n      let last = array[array.length - 1];\n\n      if (last.length < min.length) {\n        min = last;\n      }\n    });\n    lines[lines.length - 1] = min;\n    decl.raws.before = lines.join('\\n');\n  }\n  /**\n   * Clone and insert new declaration\n   */\n\n\n  insert(decl, prefix, prefixes) {\n    let cloned = this.set(this.clone(decl), prefix);\n    if (!cloned) return undefined;\n    let already = decl.parent.some(i => i.prop === cloned.prop && i.value === cloned.value);\n\n    if (already) {\n      return undefined;\n    }\n\n    if (this.needCascade(decl)) {\n      cloned.raws.before = this.calcBefore(prefixes, decl, prefix);\n    }\n\n    return decl.parent.insertBefore(decl, cloned);\n  }\n  /**\n   * Did this declaration has this prefix above\n   */\n\n\n  isAlready(decl, prefixed) {\n    let already = this.all.group(decl).up(i => i.prop === prefixed);\n\n    if (!already) {\n      already = this.all.group(decl).down(i => i.prop === prefixed);\n    }\n\n    return already;\n  }\n  /**\n   * Clone and add prefixes for declaration\n   */\n\n\n  add(decl, prefix, prefixes, result) {\n    let prefixed = this.prefixed(decl.prop, prefix);\n\n    if (this.isAlready(decl, prefixed) || this.otherPrefixes(decl.value, prefix)) {\n      return undefined;\n    }\n\n    return this.insert(decl, prefix, prefixes, result);\n  }\n  /**\n   * Add spaces for visual cascade\n   */\n\n\n  process(decl, result) {\n    if (!this.needCascade(decl)) {\n      super.process(decl, result);\n      return;\n    }\n\n    let prefixes = super.process(decl, result);\n\n    if (!prefixes || !prefixes.length) {\n      return;\n    }\n\n    this.restoreBefore(decl);\n    decl.raws.before = this.calcBefore(prefixes, decl);\n  }\n  /**\n   * Return list of prefixed properties to clean old prefixes\n   */\n\n\n  old(prop, prefix) {\n    return [this.prefixed(prop, prefix)];\n  }\n\n}\n\nmodule.exports = Declaration;","map":{"version":3,"sources":["/home/silas/Desktop/Program/goldenOwl/TrainingGit/node_modules/autoprefixer/lib/declaration.js"],"names":["Prefixer","require","Browsers","utils","Declaration","check","prefixed","prop","prefix","normalize","otherPrefixes","value","other","prefixes","includes","set","decl","needCascade","_autoprefixerCascade","all","options","cascade","raw","maxPrefixed","_autoprefixerMax","max","removeNote","length","calcBefore","diff","before","Array","fill","join","restoreBefore","lines","split","min","group","up","array","last","raws","insert","cloned","clone","undefined","already","parent","some","i","insertBefore","isAlready","down","add","result","process","old","module","exports"],"mappings":"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","sourcesContent":["let Prefixer = require('./prefixer')\nlet Browsers = require('./browsers')\nlet utils = require('./utils')\n\nclass Declaration extends Prefixer {\n  /**\n   * Always true, because we already get prefixer by property name\n   */\n  check (/* decl */) {\n    return true\n  }\n\n  /**\n   * Return prefixed version of property\n   */\n  prefixed (prop, prefix) {\n    return prefix + prop\n  }\n\n  /**\n   * Return unprefixed version of property\n   */\n  normalize (prop) {\n    return prop\n  }\n\n  /**\n   * Check `value`, that it contain other prefixes, rather than `prefix`\n   */\n  otherPrefixes (value, prefix) {\n    for (let other of Browsers.prefixes()) {\n      if (other === prefix) {\n        continue\n      }\n      if (value.includes(other)) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /**\n   * Set prefix to declaration\n   */\n  set (decl, prefix) {\n    decl.prop = this.prefixed(decl.prop, prefix)\n    return decl\n  }\n\n  /**\n   * Should we use visual cascade for prefixes\n   */\n  needCascade (decl) {\n    if (!decl._autoprefixerCascade) {\n      decl._autoprefixerCascade =\n        this.all.options.cascade !== false && decl.raw('before').includes('\\n')\n    }\n    return decl._autoprefixerCascade\n  }\n\n  /**\n   * Return maximum length of possible prefixed property\n   */\n  maxPrefixed (prefixes, decl) {\n    if (decl._autoprefixerMax) {\n      return decl._autoprefixerMax\n    }\n\n    let max = 0\n    for (let prefix of prefixes) {\n      prefix = utils.removeNote(prefix)\n      if (prefix.length > max) {\n        max = prefix.length\n      }\n    }\n    decl._autoprefixerMax = max\n\n    return decl._autoprefixerMax\n  }\n\n  /**\n   * Calculate indentation to create visual cascade\n   */\n  calcBefore (prefixes, decl, prefix = '') {\n    let max = this.maxPrefixed(prefixes, decl)\n    let diff = max - utils.removeNote(prefix).length\n\n    let before = decl.raw('before')\n    if (diff > 0) {\n      before += Array(diff).fill(' ').join('')\n    }\n\n    return before\n  }\n\n  /**\n   * Remove visual cascade\n   */\n  restoreBefore (decl) {\n    let lines = decl.raw('before').split('\\n')\n    let min = lines[lines.length - 1]\n\n    this.all.group(decl).up(prefixed => {\n      let array = prefixed.raw('before').split('\\n')\n      let last = array[array.length - 1]\n      if (last.length < min.length) {\n        min = last\n      }\n    })\n\n    lines[lines.length - 1] = min\n    decl.raws.before = lines.join('\\n')\n  }\n\n  /**\n   * Clone and insert new declaration\n   */\n  insert (decl, prefix, prefixes) {\n    let cloned = this.set(this.clone(decl), prefix)\n    if (!cloned) return undefined\n\n    let already = decl.parent.some(\n      i => i.prop === cloned.prop && i.value === cloned.value\n    )\n    if (already) {\n      return undefined\n    }\n\n    if (this.needCascade(decl)) {\n      cloned.raws.before = this.calcBefore(prefixes, decl, prefix)\n    }\n    return decl.parent.insertBefore(decl, cloned)\n  }\n\n  /**\n   * Did this declaration has this prefix above\n   */\n  isAlready (decl, prefixed) {\n    let already = this.all.group(decl).up(i => i.prop === prefixed)\n    if (!already) {\n      already = this.all.group(decl).down(i => i.prop === prefixed)\n    }\n    return already\n  }\n\n  /**\n   * Clone and add prefixes for declaration\n   */\n  add (decl, prefix, prefixes, result) {\n    let prefixed = this.prefixed(decl.prop, prefix)\n    if (\n      this.isAlready(decl, prefixed) ||\n      this.otherPrefixes(decl.value, prefix)\n    ) {\n      return undefined\n    }\n    return this.insert(decl, prefix, prefixes, result)\n  }\n\n  /**\n   * Add spaces for visual cascade\n   */\n  process (decl, result) {\n    if (!this.needCascade(decl)) {\n      super.process(decl, result)\n      return\n    }\n\n    let prefixes = super.process(decl, result)\n\n    if (!prefixes || !prefixes.length) {\n      return\n    }\n\n    this.restoreBefore(decl)\n    decl.raws.before = this.calcBefore(prefixes, decl)\n  }\n\n  /**\n   * Return list of prefixed properties to clean old prefixes\n   */\n  old (prop, prefix) {\n    return [this.prefixed(prop, prefix)]\n  }\n}\n\nmodule.exports = Declaration\n"]},"metadata":{},"sourceType":"script"}