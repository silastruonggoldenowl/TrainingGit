{"ast":null,"code":"let featureQueries = require('caniuse-lite/data/features/css-featurequeries.js');\n\nlet {\n  feature\n} = require('caniuse-lite');\n\nlet {\n  parse\n} = require('postcss');\n\nlet Browsers = require('./browsers');\n\nlet brackets = require('./brackets');\n\nlet Value = require('./value');\n\nlet utils = require('./utils');\n\nlet data = feature(featureQueries);\nlet supported = [];\n\nfor (let browser in data.stats) {\n  let versions = data.stats[browser];\n\n  for (let version in versions) {\n    let support = versions[version];\n\n    if (/y/.test(support)) {\n      supported.push(browser + ' ' + version);\n    }\n  }\n}\n\nclass Supports {\n  constructor(Prefixes, all) {\n    this.Prefixes = Prefixes;\n    this.all = all;\n  }\n  /**\n   * Return prefixer only with @supports supported browsers\n   */\n\n\n  prefixer() {\n    if (this.prefixerCache) {\n      return this.prefixerCache;\n    }\n\n    let filtered = this.all.browsers.selected.filter(i => {\n      return supported.includes(i);\n    });\n    let browsers = new Browsers(this.all.browsers.data, filtered, this.all.options);\n    this.prefixerCache = new this.Prefixes(this.all.data, browsers, this.all.options);\n    return this.prefixerCache;\n  }\n  /**\n   * Parse string into declaration property and value\n   */\n\n\n  parse(str) {\n    let parts = str.split(':');\n    let prop = parts[0];\n    let value = parts[1];\n    if (!value) value = '';\n    return [prop.trim(), value.trim()];\n  }\n  /**\n   * Create virtual rule to process it by prefixer\n   */\n\n\n  virtual(str) {\n    let [prop, value] = this.parse(str);\n    let rule = parse('a{}').first;\n    rule.append({\n      prop,\n      value,\n      raws: {\n        before: ''\n      }\n    });\n    return rule;\n  }\n  /**\n   * Return array of Declaration with all necessary prefixes\n   */\n\n\n  prefixed(str) {\n    let rule = this.virtual(str);\n\n    if (this.disabled(rule.first)) {\n      return rule.nodes;\n    }\n\n    let result = {\n      warn: () => null\n    };\n    let prefixer = this.prefixer().add[rule.first.prop];\n    prefixer && prefixer.process && prefixer.process(rule.first, result);\n\n    for (let decl of rule.nodes) {\n      for (let value of this.prefixer().values('add', rule.first.prop)) {\n        value.process(decl);\n      }\n\n      Value.save(this.all, decl);\n    }\n\n    return rule.nodes;\n  }\n  /**\n   * Return true if brackets node is \"not\" word\n   */\n\n\n  isNot(node) {\n    return typeof node === 'string' && /not\\s*/i.test(node);\n  }\n  /**\n   * Return true if brackets node is \"or\" word\n   */\n\n\n  isOr(node) {\n    return typeof node === 'string' && /\\s*or\\s*/i.test(node);\n  }\n  /**\n   * Return true if brackets node is (prop: value)\n   */\n\n\n  isProp(node) {\n    return typeof node === 'object' && node.length === 1 && typeof node[0] === 'string';\n  }\n  /**\n   * Return true if prefixed property has no unprefixed\n   */\n\n\n  isHack(all, unprefixed) {\n    let check = new RegExp(`(\\\\(|\\\\s)${utils.escapeRegexp(unprefixed)}:`);\n    return !check.test(all);\n  }\n  /**\n   * Return true if we need to remove node\n   */\n\n\n  toRemove(str, all) {\n    let [prop, value] = this.parse(str);\n    let unprefixed = this.all.unprefixed(prop);\n    let cleaner = this.all.cleaner();\n\n    if (cleaner.remove[prop] && cleaner.remove[prop].remove && !this.isHack(all, unprefixed)) {\n      return true;\n    }\n\n    for (let checker of cleaner.values('remove', unprefixed)) {\n      if (checker.check(value)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Remove all unnecessary prefixes\n   */\n\n\n  remove(nodes, all) {\n    let i = 0;\n\n    while (i < nodes.length) {\n      if (!this.isNot(nodes[i - 1]) && this.isProp(nodes[i]) && this.isOr(nodes[i + 1])) {\n        if (this.toRemove(nodes[i][0], all)) {\n          nodes.splice(i, 2);\n          continue;\n        }\n\n        i += 2;\n        continue;\n      }\n\n      if (typeof nodes[i] === 'object') {\n        nodes[i] = this.remove(nodes[i], all);\n      }\n\n      i += 1;\n    }\n\n    return nodes;\n  }\n  /**\n   * Clean brackets with one child\n   */\n\n\n  cleanBrackets(nodes) {\n    return nodes.map(i => {\n      if (typeof i !== 'object') {\n        return i;\n      }\n\n      if (i.length === 1 && typeof i[0] === 'object') {\n        return this.cleanBrackets(i[0]);\n      }\n\n      return this.cleanBrackets(i);\n    });\n  }\n  /**\n   * Add \" or \" between properties and convert it to brackets format\n   */\n\n\n  convert(progress) {\n    let result = [''];\n\n    for (let i of progress) {\n      result.push([`${i.prop}: ${i.value}`]);\n      result.push(' or ');\n    }\n\n    result[result.length - 1] = '';\n    return result;\n  }\n  /**\n   * Compress value functions into a string nodes\n   */\n\n\n  normalize(nodes) {\n    if (typeof nodes !== 'object') {\n      return nodes;\n    }\n\n    nodes = nodes.filter(i => i !== '');\n\n    if (typeof nodes[0] === 'string' && nodes[0].includes(':')) {\n      return [brackets.stringify(nodes)];\n    }\n\n    return nodes.map(i => this.normalize(i));\n  }\n  /**\n   * Add prefixes\n   */\n\n\n  add(nodes, all) {\n    return nodes.map(i => {\n      if (this.isProp(i)) {\n        let prefixed = this.prefixed(i[0]);\n\n        if (prefixed.length > 1) {\n          return this.convert(prefixed);\n        }\n\n        return i;\n      }\n\n      if (typeof i === 'object') {\n        return this.add(i, all);\n      }\n\n      return i;\n    });\n  }\n  /**\n   * Add prefixed declaration\n   */\n\n\n  process(rule) {\n    let ast = brackets.parse(rule.params);\n    ast = this.normalize(ast);\n    ast = this.remove(ast, rule.params);\n    ast = this.add(ast, rule.params);\n    ast = this.cleanBrackets(ast);\n    rule.params = brackets.stringify(ast);\n  }\n  /**\n   * Check global options\n   */\n\n\n  disabled(node) {\n    if (!this.all.options.grid) {\n      if (node.prop === 'display' && node.value.includes('grid')) {\n        return true;\n      }\n\n      if (node.prop.includes('grid') || node.prop === 'justify-items') {\n        return true;\n      }\n    }\n\n    if (this.all.options.flexbox === false) {\n      if (node.prop === 'display' && node.value.includes('flex')) {\n        return true;\n      }\n\n      let other = ['order', 'justify-content', 'align-items', 'align-content'];\n\n      if (node.prop.includes('flex') || other.includes(node.prop)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nmodule.exports = Supports;","map":{"version":3,"sources":["/home/silas/Desktop/Program/goldenOwl/TrainingGit/node_modules/autoprefixer/lib/supports.js"],"names":["featureQueries","require","feature","parse","Browsers","brackets","Value","utils","data","supported","browser","stats","versions","version","support","test","push","Supports","constructor","Prefixes","all","prefixer","prefixerCache","filtered","browsers","selected","filter","i","includes","options","str","parts","split","prop","value","trim","virtual","rule","first","append","raws","before","prefixed","disabled","nodes","result","warn","add","process","decl","values","save","isNot","node","isOr","isProp","length","isHack","unprefixed","check","RegExp","escapeRegexp","toRemove","cleaner","remove","checker","splice","cleanBrackets","map","convert","progress","normalize","stringify","ast","params","grid","flexbox","other","module","exports"],"mappings":"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","sourcesContent":["let featureQueries = require('caniuse-lite/data/features/css-featurequeries.js')\nlet { feature } = require('caniuse-lite')\nlet { parse } = require('postcss')\n\nlet Browsers = require('./browsers')\nlet brackets = require('./brackets')\nlet Value = require('./value')\nlet utils = require('./utils')\n\nlet data = feature(featureQueries)\n\nlet supported = []\nfor (let browser in data.stats) {\n  let versions = data.stats[browser]\n  for (let version in versions) {\n    let support = versions[version]\n    if (/y/.test(support)) {\n      supported.push(browser + ' ' + version)\n    }\n  }\n}\n\nclass Supports {\n  constructor (Prefixes, all) {\n    this.Prefixes = Prefixes\n    this.all = all\n  }\n\n  /**\n   * Return prefixer only with @supports supported browsers\n   */\n  prefixer () {\n    if (this.prefixerCache) {\n      return this.prefixerCache\n    }\n\n    let filtered = this.all.browsers.selected.filter(i => {\n      return supported.includes(i)\n    })\n\n    let browsers = new Browsers(\n      this.all.browsers.data,\n      filtered,\n      this.all.options\n    )\n    this.prefixerCache = new this.Prefixes(\n      this.all.data,\n      browsers,\n      this.all.options\n    )\n    return this.prefixerCache\n  }\n\n  /**\n   * Parse string into declaration property and value\n   */\n  parse (str) {\n    let parts = str.split(':')\n    let prop = parts[0]\n    let value = parts[1]\n    if (!value) value = ''\n    return [prop.trim(), value.trim()]\n  }\n\n  /**\n   * Create virtual rule to process it by prefixer\n   */\n  virtual (str) {\n    let [prop, value] = this.parse(str)\n    let rule = parse('a{}').first\n    rule.append({ prop, value, raws: { before: '' } })\n    return rule\n  }\n\n  /**\n   * Return array of Declaration with all necessary prefixes\n   */\n  prefixed (str) {\n    let rule = this.virtual(str)\n    if (this.disabled(rule.first)) {\n      return rule.nodes\n    }\n\n    let result = { warn: () => null }\n\n    let prefixer = this.prefixer().add[rule.first.prop]\n    prefixer && prefixer.process && prefixer.process(rule.first, result)\n\n    for (let decl of rule.nodes) {\n      for (let value of this.prefixer().values('add', rule.first.prop)) {\n        value.process(decl)\n      }\n      Value.save(this.all, decl)\n    }\n\n    return rule.nodes\n  }\n\n  /**\n   * Return true if brackets node is \"not\" word\n   */\n  isNot (node) {\n    return typeof node === 'string' && /not\\s*/i.test(node)\n  }\n\n  /**\n   * Return true if brackets node is \"or\" word\n   */\n  isOr (node) {\n    return typeof node === 'string' && /\\s*or\\s*/i.test(node)\n  }\n\n  /**\n   * Return true if brackets node is (prop: value)\n   */\n  isProp (node) {\n    return (\n      typeof node === 'object' &&\n      node.length === 1 &&\n      typeof node[0] === 'string'\n    )\n  }\n\n  /**\n   * Return true if prefixed property has no unprefixed\n   */\n  isHack (all, unprefixed) {\n    let check = new RegExp(`(\\\\(|\\\\s)${utils.escapeRegexp(unprefixed)}:`)\n    return !check.test(all)\n  }\n\n  /**\n   * Return true if we need to remove node\n   */\n  toRemove (str, all) {\n    let [prop, value] = this.parse(str)\n    let unprefixed = this.all.unprefixed(prop)\n\n    let cleaner = this.all.cleaner()\n\n    if (\n      cleaner.remove[prop] &&\n      cleaner.remove[prop].remove &&\n      !this.isHack(all, unprefixed)\n    ) {\n      return true\n    }\n\n    for (let checker of cleaner.values('remove', unprefixed)) {\n      if (checker.check(value)) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  /**\n   * Remove all unnecessary prefixes\n   */\n  remove (nodes, all) {\n    let i = 0\n    while (i < nodes.length) {\n      if (\n        !this.isNot(nodes[i - 1]) &&\n        this.isProp(nodes[i]) &&\n        this.isOr(nodes[i + 1])\n      ) {\n        if (this.toRemove(nodes[i][0], all)) {\n          nodes.splice(i, 2)\n          continue\n        }\n\n        i += 2\n        continue\n      }\n\n      if (typeof nodes[i] === 'object') {\n        nodes[i] = this.remove(nodes[i], all)\n      }\n\n      i += 1\n    }\n    return nodes\n  }\n\n  /**\n   * Clean brackets with one child\n   */\n  cleanBrackets (nodes) {\n    return nodes.map(i => {\n      if (typeof i !== 'object') {\n        return i\n      }\n\n      if (i.length === 1 && typeof i[0] === 'object') {\n        return this.cleanBrackets(i[0])\n      }\n\n      return this.cleanBrackets(i)\n    })\n  }\n\n  /**\n   * Add \" or \" between properties and convert it to brackets format\n   */\n  convert (progress) {\n    let result = ['']\n    for (let i of progress) {\n      result.push([`${i.prop}: ${i.value}`])\n      result.push(' or ')\n    }\n    result[result.length - 1] = ''\n    return result\n  }\n\n  /**\n   * Compress value functions into a string nodes\n   */\n  normalize (nodes) {\n    if (typeof nodes !== 'object') {\n      return nodes\n    }\n\n    nodes = nodes.filter(i => i !== '')\n    if (typeof nodes[0] === 'string' && nodes[0].includes(':')) {\n      return [brackets.stringify(nodes)]\n    }\n\n    return nodes.map(i => this.normalize(i))\n  }\n\n  /**\n   * Add prefixes\n   */\n  add (nodes, all) {\n    return nodes.map(i => {\n      if (this.isProp(i)) {\n        let prefixed = this.prefixed(i[0])\n        if (prefixed.length > 1) {\n          return this.convert(prefixed)\n        }\n\n        return i\n      }\n\n      if (typeof i === 'object') {\n        return this.add(i, all)\n      }\n\n      return i\n    })\n  }\n\n  /**\n   * Add prefixed declaration\n   */\n  process (rule) {\n    let ast = brackets.parse(rule.params)\n    ast = this.normalize(ast)\n    ast = this.remove(ast, rule.params)\n    ast = this.add(ast, rule.params)\n    ast = this.cleanBrackets(ast)\n    rule.params = brackets.stringify(ast)\n  }\n\n  /**\n   * Check global options\n   */\n  disabled (node) {\n    if (!this.all.options.grid) {\n      if (node.prop === 'display' && node.value.includes('grid')) {\n        return true\n      }\n      if (node.prop.includes('grid') || node.prop === 'justify-items') {\n        return true\n      }\n    }\n\n    if (this.all.options.flexbox === false) {\n      if (node.prop === 'display' && node.value.includes('flex')) {\n        return true\n      }\n      let other = ['order', 'justify-content', 'align-items', 'align-content']\n      if (node.prop.includes('flex') || other.includes(node.prop)) {\n        return true\n      }\n    }\n\n    return false\n  }\n}\n\nmodule.exports = Supports\n"]},"metadata":{},"sourceType":"script"}