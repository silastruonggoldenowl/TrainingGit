{"ast":null,"code":"let Fraction = require('fraction.js');\n\nlet Prefixer = require('./prefixer');\n\nlet utils = require('./utils');\n\nconst REGEXP = /(min|max)-resolution\\s*:\\s*\\d*\\.?\\d+(dppx|dpcm|dpi|x)/gi;\nconst SPLIT = /(min|max)-resolution(\\s*:\\s*)(\\d*\\.?\\d+)(dppx|dpcm|dpi|x)/i;\n\nclass Resolution extends Prefixer {\n  /**\n   * Return prefixed query name\n   */\n  prefixName(prefix, name) {\n    if (prefix === '-moz-') {\n      return name + '--moz-device-pixel-ratio';\n    } else {\n      return prefix + name + '-device-pixel-ratio';\n    }\n  }\n  /**\n   * Return prefixed query\n   */\n\n\n  prefixQuery(prefix, name, colon, value, units) {\n    value = new Fraction(value); // 1dpcm = 2.54dpi\n    // 1dppx = 96dpi\n\n    if (units === 'dpi') {\n      value = value.div(96);\n    } else if (units === 'dpcm') {\n      value = value.mul(2.54).div(96);\n    }\n\n    value = value.simplify();\n\n    if (prefix === '-o-') {\n      value = value.n + '/' + value.d;\n    }\n\n    return this.prefixName(prefix, name) + colon + value;\n  }\n  /**\n   * Remove prefixed queries\n   */\n\n\n  clean(rule) {\n    if (!this.bad) {\n      this.bad = [];\n\n      for (let prefix of this.prefixes) {\n        this.bad.push(this.prefixName(prefix, 'min'));\n        this.bad.push(this.prefixName(prefix, 'max'));\n      }\n    }\n\n    rule.params = utils.editList(rule.params, queries => {\n      return queries.filter(query => this.bad.every(i => !query.includes(i)));\n    });\n  }\n  /**\n   * Add prefixed queries\n   */\n\n\n  process(rule) {\n    let parent = this.parentPrefix(rule);\n    let prefixes = parent ? [parent] : this.prefixes;\n    rule.params = utils.editList(rule.params, (origin, prefixed) => {\n      for (let query of origin) {\n        if (!query.includes('min-resolution') && !query.includes('max-resolution')) {\n          prefixed.push(query);\n          continue;\n        }\n\n        for (let prefix of prefixes) {\n          let processed = query.replace(REGEXP, str => {\n            let parts = str.match(SPLIT);\n            return this.prefixQuery(prefix, parts[1], parts[2], parts[3], parts[4]);\n          });\n          prefixed.push(processed);\n        }\n\n        prefixed.push(query);\n      }\n\n      return utils.uniq(prefixed);\n    });\n  }\n\n}\n\nmodule.exports = Resolution;","map":{"version":3,"sources":["/home/silas/Desktop/Program/goldenOwl/TrainingGit/node_modules/autoprefixer/lib/resolution.js"],"names":["Fraction","require","Prefixer","utils","REGEXP","SPLIT","Resolution","prefixName","prefix","name","prefixQuery","colon","value","units","div","mul","simplify","n","d","clean","rule","bad","prefixes","push","params","editList","queries","filter","query","every","i","includes","process","parent","parentPrefix","origin","prefixed","processed","replace","str","parts","match","uniq","module","exports"],"mappings":"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","sourcesContent":["let Fraction = require('fraction.js')\n\nlet Prefixer = require('./prefixer')\nlet utils = require('./utils')\n\nconst REGEXP = /(min|max)-resolution\\s*:\\s*\\d*\\.?\\d+(dppx|dpcm|dpi|x)/gi\nconst SPLIT = /(min|max)-resolution(\\s*:\\s*)(\\d*\\.?\\d+)(dppx|dpcm|dpi|x)/i\n\nclass Resolution extends Prefixer {\n  /**\n   * Return prefixed query name\n   */\n  prefixName (prefix, name) {\n    if (prefix === '-moz-') {\n      return name + '--moz-device-pixel-ratio'\n    } else {\n      return prefix + name + '-device-pixel-ratio'\n    }\n  }\n\n  /**\n   * Return prefixed query\n   */\n  prefixQuery (prefix, name, colon, value, units) {\n    value = new Fraction(value)\n\n    // 1dpcm = 2.54dpi\n    // 1dppx = 96dpi\n    if (units === 'dpi') {\n      value = value.div(96)\n    } else if (units === 'dpcm') {\n      value = value.mul(2.54).div(96)\n    }\n    value = value.simplify()\n\n    if (prefix === '-o-') {\n      value = value.n + '/' + value.d\n    }\n    return this.prefixName(prefix, name) + colon + value\n  }\n\n  /**\n   * Remove prefixed queries\n   */\n  clean (rule) {\n    if (!this.bad) {\n      this.bad = []\n      for (let prefix of this.prefixes) {\n        this.bad.push(this.prefixName(prefix, 'min'))\n        this.bad.push(this.prefixName(prefix, 'max'))\n      }\n    }\n\n    rule.params = utils.editList(rule.params, queries => {\n      return queries.filter(query => this.bad.every(i => !query.includes(i)))\n    })\n  }\n\n  /**\n   * Add prefixed queries\n   */\n  process (rule) {\n    let parent = this.parentPrefix(rule)\n    let prefixes = parent ? [parent] : this.prefixes\n\n    rule.params = utils.editList(rule.params, (origin, prefixed) => {\n      for (let query of origin) {\n        if (\n          !query.includes('min-resolution') &&\n          !query.includes('max-resolution')\n        ) {\n          prefixed.push(query)\n          continue\n        }\n\n        for (let prefix of prefixes) {\n          let processed = query.replace(REGEXP, str => {\n            let parts = str.match(SPLIT)\n            return this.prefixQuery(\n              prefix,\n              parts[1],\n              parts[2],\n              parts[3],\n              parts[4]\n            )\n          })\n          prefixed.push(processed)\n        }\n        prefixed.push(query)\n      }\n\n      return utils.uniq(prefixed)\n    })\n  }\n}\n\nmodule.exports = Resolution\n"]},"metadata":{},"sourceType":"script"}