{"ast":null,"code":"'use strict';\n\nlet {\n  existsSync,\n  readFileSync\n} = require('fs');\n\nlet {\n  dirname,\n  join\n} = require('path');\n\nlet mozilla = require('source-map');\n\nfunction fromBase64(str) {\n  if (Buffer) {\n    return Buffer.from(str, 'base64').toString();\n  } else {\n    // istanbul ignore next\n    return window.atob(str);\n  }\n}\n\nclass PreviousMap {\n  constructor(css, opts) {\n    if (opts.map === false) return;\n    this.loadAnnotation(css);\n    this.inline = this.startWith(this.annotation, 'data:');\n    let prev = opts.map ? opts.map.prev : undefined;\n    let text = this.loadMap(opts.from, prev);\n\n    if (!this.mapFile && opts.from) {\n      this.mapFile = opts.from;\n    }\n\n    if (this.mapFile) this.root = dirname(this.mapFile);\n    if (text) this.text = text;\n  }\n\n  consumer() {\n    if (!this.consumerCache) {\n      this.consumerCache = new mozilla.SourceMapConsumer(this.text);\n    }\n\n    return this.consumerCache;\n  }\n\n  withContent() {\n    return !!(this.consumer().sourcesContent && this.consumer().sourcesContent.length > 0);\n  }\n\n  startWith(string, start) {\n    if (!string) return false;\n    return string.substr(0, start.length) === start;\n  }\n\n  getAnnotationURL(sourceMapString) {\n    return sourceMapString.match(/\\/\\*\\s*# sourceMappingURL=(.*)\\s*\\*\\//)[1].trim();\n  }\n\n  loadAnnotation(css) {\n    let annotations = css.match(/\\/\\*\\s*# sourceMappingURL=.*\\s*\\*\\//gm);\n\n    if (annotations && annotations.length > 0) {\n      // Locate the last sourceMappingURL to avoid picking up\n      // sourceMappingURLs from comments, strings, etc.\n      let lastAnnotation = annotations[annotations.length - 1];\n\n      if (lastAnnotation) {\n        this.annotation = this.getAnnotationURL(lastAnnotation);\n      }\n    }\n  }\n\n  decodeInline(text) {\n    let baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/;\n    let baseUri = /^data:application\\/json;base64,/;\n    let charsetUri = /^data:application\\/json;charset=utf-?8,/;\n    let uri = /^data:application\\/json,/;\n\n    if (charsetUri.test(text) || uri.test(text)) {\n      return decodeURIComponent(text.substr(RegExp.lastMatch.length));\n    }\n\n    if (baseCharsetUri.test(text) || baseUri.test(text)) {\n      return fromBase64(text.substr(RegExp.lastMatch.length));\n    }\n\n    let encoding = text.match(/data:application\\/json;([^,]+),/)[1];\n    throw new Error('Unsupported source map encoding ' + encoding);\n  }\n\n  loadFile(path) {\n    this.root = dirname(path);\n\n    if (existsSync(path)) {\n      this.mapFile = path;\n      return readFileSync(path, 'utf-8').toString().trim();\n    }\n  }\n\n  loadMap(file, prev) {\n    if (prev === false) return false;\n\n    if (prev) {\n      if (typeof prev === 'string') {\n        return prev;\n      } else if (typeof prev === 'function') {\n        let prevPath = prev(file);\n\n        if (prevPath) {\n          let map = this.loadFile(prevPath);\n\n          if (!map) {\n            throw new Error('Unable to load previous source map: ' + prevPath.toString());\n          }\n\n          return map;\n        }\n      } else if (prev instanceof mozilla.SourceMapConsumer) {\n        return mozilla.SourceMapGenerator.fromSourceMap(prev).toString();\n      } else if (prev instanceof mozilla.SourceMapGenerator) {\n        return prev.toString();\n      } else if (this.isMap(prev)) {\n        return JSON.stringify(prev);\n      } else {\n        throw new Error('Unsupported previous source map format: ' + prev.toString());\n      }\n    } else if (this.inline) {\n      return this.decodeInline(this.annotation);\n    } else if (this.annotation) {\n      let map = this.annotation;\n      if (file) map = join(dirname(file), map);\n      return this.loadFile(map);\n    }\n  }\n\n  isMap(map) {\n    if (typeof map !== 'object') return false;\n    return typeof map.mappings === 'string' || typeof map._mappings === 'string' || Array.isArray(map.sections);\n  }\n\n}\n\nmodule.exports = PreviousMap;\nPreviousMap.default = PreviousMap;","map":{"version":3,"sources":["/home/silas/Desktop/Program/goldenOwl/TrainingGit/node_modules/postcss/lib/previous-map.js"],"names":["existsSync","readFileSync","require","dirname","join","mozilla","fromBase64","str","Buffer","from","toString","window","atob","PreviousMap","constructor","css","opts","map","loadAnnotation","inline","startWith","annotation","prev","undefined","text","loadMap","mapFile","root","consumer","consumerCache","SourceMapConsumer","withContent","sourcesContent","length","string","start","substr","getAnnotationURL","sourceMapString","match","trim","annotations","lastAnnotation","decodeInline","baseCharsetUri","baseUri","charsetUri","uri","test","decodeURIComponent","RegExp","lastMatch","encoding","Error","loadFile","path","file","prevPath","SourceMapGenerator","fromSourceMap","isMap","JSON","stringify","mappings","_mappings","Array","isArray","sections","module","exports","default"],"mappings":"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","sourcesContent":["'use strict'\n\nlet { existsSync, readFileSync } = require('fs')\nlet { dirname, join } = require('path')\nlet mozilla = require('source-map')\n\nfunction fromBase64 (str) {\n  if (Buffer) {\n    return Buffer.from(str, 'base64').toString()\n  } else {\n    // istanbul ignore next\n    return window.atob(str)\n  }\n}\n\nclass PreviousMap {\n  constructor (css, opts) {\n    if (opts.map === false) return\n    this.loadAnnotation(css)\n    this.inline = this.startWith(this.annotation, 'data:')\n\n    let prev = opts.map ? opts.map.prev : undefined\n    let text = this.loadMap(opts.from, prev)\n    if (!this.mapFile && opts.from) {\n      this.mapFile = opts.from\n    }\n    if (this.mapFile) this.root = dirname(this.mapFile)\n    if (text) this.text = text\n  }\n\n  consumer () {\n    if (!this.consumerCache) {\n      this.consumerCache = new mozilla.SourceMapConsumer(this.text)\n    }\n    return this.consumerCache\n  }\n\n  withContent () {\n    return !!(\n      this.consumer().sourcesContent &&\n      this.consumer().sourcesContent.length > 0\n    )\n  }\n\n  startWith (string, start) {\n    if (!string) return false\n    return string.substr(0, start.length) === start\n  }\n\n  getAnnotationURL (sourceMapString) {\n    return sourceMapString\n      .match(/\\/\\*\\s*# sourceMappingURL=(.*)\\s*\\*\\//)[1]\n      .trim()\n  }\n\n  loadAnnotation (css) {\n    let annotations = css.match(/\\/\\*\\s*# sourceMappingURL=.*\\s*\\*\\//gm)\n\n    if (annotations && annotations.length > 0) {\n      // Locate the last sourceMappingURL to avoid picking up\n      // sourceMappingURLs from comments, strings, etc.\n      let lastAnnotation = annotations[annotations.length - 1]\n      if (lastAnnotation) {\n        this.annotation = this.getAnnotationURL(lastAnnotation)\n      }\n    }\n  }\n\n  decodeInline (text) {\n    let baseCharsetUri = /^data:application\\/json;charset=utf-?8;base64,/\n    let baseUri = /^data:application\\/json;base64,/\n    let charsetUri = /^data:application\\/json;charset=utf-?8,/\n    let uri = /^data:application\\/json,/\n\n    if (charsetUri.test(text) || uri.test(text)) {\n      return decodeURIComponent(text.substr(RegExp.lastMatch.length))\n    }\n\n    if (baseCharsetUri.test(text) || baseUri.test(text)) {\n      return fromBase64(text.substr(RegExp.lastMatch.length))\n    }\n\n    let encoding = text.match(/data:application\\/json;([^,]+),/)[1]\n    throw new Error('Unsupported source map encoding ' + encoding)\n  }\n\n  loadFile (path) {\n    this.root = dirname(path)\n    if (existsSync(path)) {\n      this.mapFile = path\n      return readFileSync(path, 'utf-8').toString().trim()\n    }\n  }\n\n  loadMap (file, prev) {\n    if (prev === false) return false\n\n    if (prev) {\n      if (typeof prev === 'string') {\n        return prev\n      } else if (typeof prev === 'function') {\n        let prevPath = prev(file)\n        if (prevPath) {\n          let map = this.loadFile(prevPath)\n          if (!map) {\n            throw new Error(\n              'Unable to load previous source map: ' + prevPath.toString()\n            )\n          }\n          return map\n        }\n      } else if (prev instanceof mozilla.SourceMapConsumer) {\n        return mozilla.SourceMapGenerator.fromSourceMap(prev).toString()\n      } else if (prev instanceof mozilla.SourceMapGenerator) {\n        return prev.toString()\n      } else if (this.isMap(prev)) {\n        return JSON.stringify(prev)\n      } else {\n        throw new Error(\n          'Unsupported previous source map format: ' + prev.toString()\n        )\n      }\n    } else if (this.inline) {\n      return this.decodeInline(this.annotation)\n    } else if (this.annotation) {\n      let map = this.annotation\n      if (file) map = join(dirname(file), map)\n      return this.loadFile(map)\n    }\n  }\n\n  isMap (map) {\n    if (typeof map !== 'object') return false\n    return (\n      typeof map.mappings === 'string' ||\n      typeof map._mappings === 'string' ||\n      Array.isArray(map.sections)\n    )\n  }\n}\n\nmodule.exports = PreviousMap\nPreviousMap.default = PreviousMap\n"]},"metadata":{},"sourceType":"script"}