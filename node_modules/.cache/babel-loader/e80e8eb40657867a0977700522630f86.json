{"ast":null,"code":"let {\n  list\n} = require('postcss');\n\nmodule.exports = {\n  /**\n   * Throw special error, to tell beniary,\n   * that this error is from Autoprefixer.\n   */\n  error(text) {\n    let err = new Error(text);\n    err.autoprefixer = true;\n    throw err;\n  },\n\n  /**\n   * Return array, that doesn’t contain duplicates.\n   */\n  uniq(array) {\n    return [...new Set(array)];\n  },\n\n  /**\n   * Return \"-webkit-\" on \"-webkit- old\"\n   */\n  removeNote(string) {\n    if (!string.includes(' ')) {\n      return string;\n    }\n\n    return string.split(' ')[0];\n  },\n\n  /**\n   * Escape RegExp symbols\n   */\n  escapeRegexp(string) {\n    return string.replace(/[$()*+-.?[\\\\\\]^{|}]/g, '\\\\$&');\n  },\n\n  /**\n   * Return regexp to check, that CSS string contain word\n   */\n  regexp(word, escape = true) {\n    if (escape) {\n      word = this.escapeRegexp(word);\n    }\n\n    return new RegExp(`(^|[\\\\s,(])(${word}($|[\\\\s(,]))`, 'gi');\n  },\n\n  /**\n   * Change comma list\n   */\n  editList(value, callback) {\n    let origin = list.comma(value);\n    let changed = callback(origin, []);\n\n    if (origin === changed) {\n      return value;\n    }\n\n    let join = value.match(/,\\s*/);\n    join = join ? join[0] : ', ';\n    return changed.join(join);\n  },\n\n  /**\n   * Split the selector into parts.\n   * It returns 3 level deep array because selectors can be comma\n   * separated (1), space separated (2), and combined (3)\n   * @param {String} selector selector string\n   * @return {Array<Array<Array>>} 3 level deep array of split selector\n   * @see utils.test.js for examples\n   */\n  splitSelector(selector) {\n    return list.comma(selector).map(i => {\n      return list.space(i).map(k => {\n        return k.split(/(?=\\.|#)/g);\n      });\n    });\n  }\n\n};","map":{"version":3,"sources":["/home/silas/Desktop/Program/goldenOwl/TrainingGit/node_modules/autoprefixer/lib/utils.js"],"names":["list","require","module","exports","error","text","err","Error","autoprefixer","uniq","array","Set","removeNote","string","includes","split","escapeRegexp","replace","regexp","word","escape","RegExp","editList","value","callback","origin","comma","changed","join","match","splitSelector","selector","map","i","space","k"],"mappings":"AAAA,IAAI;AAAEA,EAAAA;AAAF,IAAWC,OAAO,CAAC,SAAD,CAAtB;;AAEAC,MAAM,CAACC,OAAP,GAAiB;AACf;AACF;AACA;AACA;AACEC,EAAAA,KAAK,CAAEC,IAAF,EAAQ;AACX,QAAIC,GAAG,GAAG,IAAIC,KAAJ,CAAUF,IAAV,CAAV;AACAC,IAAAA,GAAG,CAACE,YAAJ,GAAmB,IAAnB;AACA,UAAMF,GAAN;AACD,GATc;;AAWf;AACF;AACA;AACEG,EAAAA,IAAI,CAAEC,KAAF,EAAS;AACX,WAAO,CAAC,GAAG,IAAIC,GAAJ,CAAQD,KAAR,CAAJ,CAAP;AACD,GAhBc;;AAkBf;AACF;AACA;AACEE,EAAAA,UAAU,CAAEC,MAAF,EAAU;AAClB,QAAI,CAACA,MAAM,CAACC,QAAP,CAAgB,GAAhB,CAAL,EAA2B;AACzB,aAAOD,MAAP;AACD;;AAED,WAAOA,MAAM,CAACE,KAAP,CAAa,GAAb,EAAkB,CAAlB,CAAP;AACD,GA3Bc;;AA6Bf;AACF;AACA;AACEC,EAAAA,YAAY,CAAEH,MAAF,EAAU;AACpB,WAAOA,MAAM,CAACI,OAAP,CAAe,sBAAf,EAAuC,MAAvC,CAAP;AACD,GAlCc;;AAoCf;AACF;AACA;AACEC,EAAAA,MAAM,CAAEC,IAAF,EAAQC,MAAM,GAAG,IAAjB,EAAuB;AAC3B,QAAIA,MAAJ,EAAY;AACVD,MAAAA,IAAI,GAAG,KAAKH,YAAL,CAAkBG,IAAlB,CAAP;AACD;;AACD,WAAO,IAAIE,MAAJ,CAAY,eAAcF,IAAK,cAA/B,EAA8C,IAA9C,CAAP;AACD,GA5Cc;;AA8Cf;AACF;AACA;AACEG,EAAAA,QAAQ,CAAEC,KAAF,EAASC,QAAT,EAAmB;AACzB,QAAIC,MAAM,GAAGzB,IAAI,CAAC0B,KAAL,CAAWH,KAAX,CAAb;AACA,QAAII,OAAO,GAAGH,QAAQ,CAACC,MAAD,EAAS,EAAT,CAAtB;;AAEA,QAAIA,MAAM,KAAKE,OAAf,EAAwB;AACtB,aAAOJ,KAAP;AACD;;AAED,QAAIK,IAAI,GAAGL,KAAK,CAACM,KAAN,CAAY,MAAZ,CAAX;AACAD,IAAAA,IAAI,GAAGA,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAP,GAAa,IAAxB;AACA,WAAOD,OAAO,CAACC,IAAR,CAAaA,IAAb,CAAP;AACD,GA5Dc;;AA8Df;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACEE,EAAAA,aAAa,CAAEC,QAAF,EAAY;AACvB,WAAO/B,IAAI,CAAC0B,KAAL,CAAWK,QAAX,EAAqBC,GAArB,CAAyBC,CAAC,IAAI;AACnC,aAAOjC,IAAI,CAACkC,KAAL,CAAWD,CAAX,EAAcD,GAAd,CAAkBG,CAAC,IAAI;AAC5B,eAAOA,CAAC,CAACpB,KAAF,CAAQ,WAAR,CAAP;AACD,OAFM,CAAP;AAGD,KAJM,CAAP;AAKD;;AA5Ec,CAAjB","sourcesContent":["let { list } = require('postcss')\n\nmodule.exports = {\n  /**\n   * Throw special error, to tell beniary,\n   * that this error is from Autoprefixer.\n   */\n  error (text) {\n    let err = new Error(text)\n    err.autoprefixer = true\n    throw err\n  },\n\n  /**\n   * Return array, that doesn’t contain duplicates.\n   */\n  uniq (array) {\n    return [...new Set(array)]\n  },\n\n  /**\n   * Return \"-webkit-\" on \"-webkit- old\"\n   */\n  removeNote (string) {\n    if (!string.includes(' ')) {\n      return string\n    }\n\n    return string.split(' ')[0]\n  },\n\n  /**\n   * Escape RegExp symbols\n   */\n  escapeRegexp (string) {\n    return string.replace(/[$()*+-.?[\\\\\\]^{|}]/g, '\\\\$&')\n  },\n\n  /**\n   * Return regexp to check, that CSS string contain word\n   */\n  regexp (word, escape = true) {\n    if (escape) {\n      word = this.escapeRegexp(word)\n    }\n    return new RegExp(`(^|[\\\\s,(])(${word}($|[\\\\s(,]))`, 'gi')\n  },\n\n  /**\n   * Change comma list\n   */\n  editList (value, callback) {\n    let origin = list.comma(value)\n    let changed = callback(origin, [])\n\n    if (origin === changed) {\n      return value\n    }\n\n    let join = value.match(/,\\s*/)\n    join = join ? join[0] : ', '\n    return changed.join(join)\n  },\n\n  /**\n   * Split the selector into parts.\n   * It returns 3 level deep array because selectors can be comma\n   * separated (1), space separated (2), and combined (3)\n   * @param {String} selector selector string\n   * @return {Array<Array<Array>>} 3 level deep array of split selector\n   * @see utils.test.js for examples\n   */\n  splitSelector (selector) {\n    return list.comma(selector).map(i => {\n      return list.space(i).map(k => {\n        return k.split(/(?=\\.|#)/g)\n      })\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}