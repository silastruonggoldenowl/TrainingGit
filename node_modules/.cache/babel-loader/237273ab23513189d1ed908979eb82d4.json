{"ast":null,"code":"let {\n  list\n} = require('postcss');\n\nlet OldSelector = require('./old-selector');\n\nlet Prefixer = require('./prefixer');\n\nlet Browsers = require('./browsers');\n\nlet utils = require('./utils');\n\nclass Selector extends Prefixer {\n  constructor(name, prefixes, all) {\n    super(name, prefixes, all);\n    this.regexpCache = new Map();\n  }\n  /**\n   * Is rule selectors need to be prefixed\n   */\n\n\n  check(rule) {\n    if (rule.selector.includes(this.name)) {\n      return !!rule.selector.match(this.regexp());\n    }\n\n    return false;\n  }\n  /**\n   * Return prefixed version of selector\n   */\n\n\n  prefixed(prefix) {\n    return this.name.replace(/^(\\W*)/, `$1${prefix}`);\n  }\n  /**\n   * Lazy loadRegExp for name\n   */\n\n\n  regexp(prefix) {\n    if (!this.regexpCache.has(prefix)) {\n      let name = prefix ? this.prefixed(prefix) : this.name;\n      this.regexpCache.set(prefix, new RegExp(`(^|[^:\"'=])${utils.escapeRegexp(name)}`, 'gi'));\n    }\n\n    return this.regexpCache.get(prefix);\n  }\n  /**\n   * All possible prefixes\n   */\n\n\n  possible() {\n    return Browsers.prefixes();\n  }\n  /**\n   * Return all possible selector prefixes\n   */\n\n\n  prefixeds(rule) {\n    if (rule._autoprefixerPrefixeds) {\n      if (rule._autoprefixerPrefixeds[this.name]) {\n        return rule._autoprefixerPrefixeds;\n      }\n    } else {\n      rule._autoprefixerPrefixeds = {};\n    }\n\n    let prefixeds = {};\n\n    if (rule.selector.includes(',')) {\n      let ruleParts = list.comma(rule.selector);\n      let toProcess = ruleParts.filter(el => el.includes(this.name));\n\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = toProcess.map(el => this.replace(el, prefix)).join(', ');\n      }\n    } else {\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = this.replace(rule.selector, prefix);\n      }\n    }\n\n    rule._autoprefixerPrefixeds[this.name] = prefixeds;\n    return rule._autoprefixerPrefixeds;\n  }\n  /**\n   * Is rule already prefixed before\n   */\n\n\n  already(rule, prefixeds, prefix) {\n    let index = rule.parent.index(rule) - 1;\n\n    while (index >= 0) {\n      let before = rule.parent.nodes[index];\n\n      if (before.type !== 'rule') {\n        return false;\n      }\n\n      let some = false;\n\n      for (let key in prefixeds[this.name]) {\n        let prefixed = prefixeds[this.name][key];\n\n        if (before.selector === prefixed) {\n          if (prefix === key) {\n            return true;\n          } else {\n            some = true;\n            break;\n          }\n        }\n      }\n\n      if (!some) {\n        return false;\n      }\n\n      index -= 1;\n    }\n\n    return false;\n  }\n  /**\n   * Replace selectors by prefixed one\n   */\n\n\n  replace(selector, prefix) {\n    return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`);\n  }\n  /**\n   * Clone and add prefixes for at-rule\n   */\n\n\n  add(rule, prefix) {\n    let prefixeds = this.prefixeds(rule);\n\n    if (this.already(rule, prefixeds, prefix)) {\n      return;\n    }\n\n    let cloned = this.clone(rule, {\n      selector: prefixeds[this.name][prefix]\n    });\n    rule.parent.insertBefore(rule, cloned);\n  }\n  /**\n   * Return function to fast find prefixed selector\n   */\n\n\n  old(prefix) {\n    return new OldSelector(this, prefix);\n  }\n\n}\n\nmodule.exports = Selector;","map":{"version":3,"sources":["/home/silas/Desktop/Program/goldenOwl/TrainingGit/node_modules/autoprefixer/lib/selector.js"],"names":["list","require","OldSelector","Prefixer","Browsers","utils","Selector","constructor","name","prefixes","all","regexpCache","Map","check","rule","selector","includes","match","regexp","prefixed","prefix","replace","has","set","RegExp","escapeRegexp","get","possible","prefixeds","_autoprefixerPrefixeds","ruleParts","comma","toProcess","filter","el","map","join","already","index","parent","before","nodes","type","some","key","add","cloned","clone","insertBefore","old","module","exports"],"mappings":"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","sourcesContent":["let { list } = require('postcss')\n\nlet OldSelector = require('./old-selector')\nlet Prefixer = require('./prefixer')\nlet Browsers = require('./browsers')\nlet utils = require('./utils')\n\nclass Selector extends Prefixer {\n  constructor (name, prefixes, all) {\n    super(name, prefixes, all)\n    this.regexpCache = new Map()\n  }\n\n  /**\n   * Is rule selectors need to be prefixed\n   */\n  check (rule) {\n    if (rule.selector.includes(this.name)) {\n      return !!rule.selector.match(this.regexp())\n    }\n\n    return false\n  }\n\n  /**\n   * Return prefixed version of selector\n   */\n  prefixed (prefix) {\n    return this.name.replace(/^(\\W*)/, `$1${prefix}`)\n  }\n\n  /**\n   * Lazy loadRegExp for name\n   */\n  regexp (prefix) {\n    if (!this.regexpCache.has(prefix)) {\n      let name = prefix ? this.prefixed(prefix) : this.name\n      this.regexpCache.set(\n        prefix,\n        new RegExp(`(^|[^:\"'=])${utils.escapeRegexp(name)}`, 'gi')\n      )\n    }\n\n    return this.regexpCache.get(prefix)\n  }\n\n  /**\n   * All possible prefixes\n   */\n  possible () {\n    return Browsers.prefixes()\n  }\n\n  /**\n   * Return all possible selector prefixes\n   */\n  prefixeds (rule) {\n    if (rule._autoprefixerPrefixeds) {\n      if (rule._autoprefixerPrefixeds[this.name]) {\n        return rule._autoprefixerPrefixeds\n      }\n    } else {\n      rule._autoprefixerPrefixeds = {}\n    }\n\n    let prefixeds = {}\n    if (rule.selector.includes(',')) {\n      let ruleParts = list.comma(rule.selector)\n      let toProcess = ruleParts.filter(el => el.includes(this.name))\n\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = toProcess\n          .map(el => this.replace(el, prefix))\n          .join(', ')\n      }\n    } else {\n      for (let prefix of this.possible()) {\n        prefixeds[prefix] = this.replace(rule.selector, prefix)\n      }\n    }\n\n    rule._autoprefixerPrefixeds[this.name] = prefixeds\n    return rule._autoprefixerPrefixeds\n  }\n\n  /**\n   * Is rule already prefixed before\n   */\n  already (rule, prefixeds, prefix) {\n    let index = rule.parent.index(rule) - 1\n\n    while (index >= 0) {\n      let before = rule.parent.nodes[index]\n\n      if (before.type !== 'rule') {\n        return false\n      }\n\n      let some = false\n      for (let key in prefixeds[this.name]) {\n        let prefixed = prefixeds[this.name][key]\n        if (before.selector === prefixed) {\n          if (prefix === key) {\n            return true\n          } else {\n            some = true\n            break\n          }\n        }\n      }\n      if (!some) {\n        return false\n      }\n\n      index -= 1\n    }\n\n    return false\n  }\n\n  /**\n   * Replace selectors by prefixed one\n   */\n  replace (selector, prefix) {\n    return selector.replace(this.regexp(), `$1${this.prefixed(prefix)}`)\n  }\n\n  /**\n   * Clone and add prefixes for at-rule\n   */\n  add (rule, prefix) {\n    let prefixeds = this.prefixeds(rule)\n\n    if (this.already(rule, prefixeds, prefix)) {\n      return\n    }\n\n    let cloned = this.clone(rule, { selector: prefixeds[this.name][prefix] })\n    rule.parent.insertBefore(rule, cloned)\n  }\n\n  /**\n   * Return function to fast find prefixed selector\n   */\n  old (prefix) {\n    return new OldSelector(this, prefix)\n  }\n}\n\nmodule.exports = Selector\n"]},"metadata":{},"sourceType":"script"}